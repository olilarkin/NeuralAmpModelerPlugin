name: Release Native

on:
  workflow_dispatch:
  push:
    tags:
      - "v*"

env:
  PROJECT_NAME: NeuralAmpModeler

jobs:
  create_release:
    name: Create release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{steps.create_release.outputs.upload_url}}
    steps:
      - name: Check out repository
        uses: actions/checkout@v2
        with:
          submodules: recursive

      - name: Create release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
        with:
          draft: true
          tag_name: ${{github.ref}}
          release_name: Release ${{github.ref}}
          body_path: ${{env.PROJECT_NAME}}/installer/changelog.txt

  build:
    name: Build
    needs: create_release
    runs-on: ${{matrix.os}}
    strategy:
      matrix:
        os: [macos-latest, windows-latest]
        include:
          - os: macos-latest
            build_dir: build-mac
          - os: windows-latest
            build_dir: build-win

    steps:
    - name: Check out repository
      uses: actions/checkout@v2
      with:
        submodules: recursive

    - name: Get VST3 SDK
      run: |
        cd iPlug2/Dependencies/IPlug
        ./download-iplug-sdks.sh
      shell: bash

    - name: Get Prebuilt Libs
      run: |
        cd iPlug2/Dependencies
        ./download-prebuilt-libs.sh
      shell: bash

    - name: Get Archive Name macOS
      id: mac_archivename_step
      if: matrix.os == 'macOS-latest'
      run: |
        ARCHIVE_NAME=`python3 iPlug2/Scripts/get_archive_name.py ${{env.PROJECT_NAME}} mac full`
        echo "::set-output name=archive_name::$ARCHIVE_NAME"
      shell: bash

    - name: Build macOS
      if: matrix.os == 'macOS-latest'
      run: |
        cd ${{env.PROJECT_NAME}}/scripts
        ./makedist-mac.sh full installer
      shell: bash

    - name: Upload mac DSYMs release asset
      if: matrix.os == 'macOS-latest'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
      with:
        upload_url: ${{needs.create_release.outputs.upload_url}}
        asset_path: ${{env.PROJECT_NAME}}/${{matrix.build_dir}}/out/${{steps.mac_archivename_step.outputs.archive_name}}-dSYMs.zip
        asset_name: ${{steps.mac_archivename_step.outputs.archive_name}}-dSYMs.zip
        asset_content_type: application/zip

    - name: Upload mac dmg release asset
      if: matrix.os == 'macOS-latest'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
      with:
        upload_url: ${{needs.create_release.outputs.upload_url}}
        asset_path: ${{env.PROJECT_NAME}}/${{matrix.build_dir}}/out/${{steps.mac_archivename_step.outputs.archive_name}}.dmg
        asset_name: ${{steps.mac_archivename_step.outputs.archive_name}}.dmg
        asset_content_type: application/octet-stream

    - name: Add msbuild to PATH (Windows)
      if: matrix.os == 'windows-latest'
      uses: microsoft/setup-msbuild@v1.0.2

    - name: Setup Python3
      if: matrix.os == 'windows-latest'
      uses: actions/setup-python@v2
      with:
        python-version: '3.x'
        architecture: 'x64'

    - name: Get Archive Name Windows
      id: win_archivename_step
      if: matrix.os == 'windows-latest'
      run: |
        ARCHIVE_NAME=`python.exe iPlug2/Scripts/get_archive_name.py ${{env.PROJECT_NAME}} win full`
        echo "::set-output name=archive_name::$ARCHIVE_NAME"
      shell: bash

    - name: Build Windows
      if: matrix.os == 'windows-latest'
      run: |
        cd ${{env.PROJECT_NAME}}\scripts
        .\makedist-win.bat full installer
      shell: pwsh

    - name: Upload Windows pdb release asset
      if: matrix.os == 'windows-latest'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
      with:
        upload_url: ${{needs.create_release.outputs.upload_url}}
        asset_path: ${{env.PROJECT_NAME}}/${{matrix.build_dir}}/out/${{steps.win_archivename_step.outputs.archive_name}}-pdbs.zip
        asset_name: ${{steps.win_archivename_step.outputs.archive_name}}-pdbs.zip
        asset_content_type: application/zip

    - name: Upload Windows zip release asset
      if: matrix.os == 'windows-latest'
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
      with:
        upload_url: ${{needs.create_release.outputs.upload_url}}
        asset_path: ${{env.PROJECT_NAME}}/${{matrix.build_dir}}/out/${{steps.win_archivename_step.outputs.archive_name}}.zip
        asset_name: ${{steps.win_archivename_step.outputs.archive_name}}.zip
        asset_content_type: application/zip
				- name: Azure Container Apps Build and Deploy
  uses: Azure/container-apps-deploy-action@v1
  with:
    # Absolute path on the GitHub runner of the source application code to be built.
    appSourcePath: # optional
    # The name of the Azure Container Registry that the runnable application image will be pushed to.
    acrName: # optional
    # 'The username used to authenticate push requests to the provided Azure Container Registry. If not provided, an
access token will be generated via "az acr login" and provided to "docker login" to authenticate the requests.'

    acrUsername: # optional
    # 'The password used to authenticate push requests to the provided Azure Container Registry. If not provided, an
access token will be generated via "az acr login" and provided to "docker login" to authenticate the requests.'

    acrPassword: # optional
    # The base URL of the Container Registry that the runnable application image will be pushed to.
    registryUrl: # optional
    # The username used to authenticate push requests to the provided Container Registry using the "docker login" action.
    registryUsername: # optional
    # The password used to authenticate push requests to the provided Container Registry using the "docker login" action.
    registryPassword: # optional
    # 'Azure credentials used by the `azure/login` action to authenticate Azure CLI requests if the user has not
previously authenticated in the workflow calling this action.'

    azureCredentials: # optional
    # 'The custom name of the image that is to be built, pushed to the Container Registry and deployed to the Container App by this action.
Note: this image name should include the registry server; e.g., <registryUrl>/<repo>:<tag>. If this argument is
not provided, a default image name will be constructed in the form of
<acr-name>.azurecr.io/github-action/container-app:<github-run-id>.<github-run-attempt>.'

    imageToBuild: # optional
    # 'The custom name of an image that has already been pushed to the Container Registry and will be deployed to the Container App by this
action. Note: this image name should include the registry server; e.g., <registryUrl>/<repo>:<tag>. If this
argument is not provided, the value provided (or determined) for the "imageToBuild" argument will be used.'

    imageToDeploy: # optional
    # 'Relative path to the Dockerfile in the provided application source that should be used to build the image that is
then pushed to the Container Registry and deployed to the Container App. If not provided, this action will check if there is a file
named "Dockerfile" in the provided application source and use that to build the image. Otherwise, the Oryx++
Builder will be used to create the image.'

    dockerfilePath: # optional
    # 'The name of the Azure Container App that will be created or updated. If not provided, this value will be
gh-action-app-<github-run-id>-<github-run-attempt>.'

    containerAppName: # optional, default is gh-action-app-${{ github.run_id }}-${{ github.run_attempt }}
    # 'The existing resource group that the Azure Container App will be created in. If not provided, this value will be
<container-app-name>-rg and its existence will first be checked before attempting to create it.'

    resourceGroup: # optional
    # 'The name of the Azure Container App environment to use with the application. If not provided, an existing
environment in the resource group of the Container App will be used, otherwise, an environment will be created in
the format <container-app-name>-env'

    containerAppEnvironment: # optional
    # 'The platform version stack that the application runs in when deployed to the Azure Container App. This should
be provided in the format <platform>:<version>. If not provided, this value is determined by Oryx based on the
contents of the provided application. Please view the following document for more information on the supported
runtime stacks for Oryx:
https://github.com/microsoft/Oryx/blob/main/doc/supportedRuntimeVersions.md'

    runtimeStack: # optional
    # 'The designated port for the application to run on. If no value is provided and the builder is used to build the
runnable application image, the target port will be set to 80 for Python applications and 8080 for all other
platform applications. If no value is provided when creating a Container App, the target port will be set to 80 by
default. Note: when using this action to update a Container App, the target port may be updated if not provided
based on changes to the ingress property.

    targetPort: # optional
    # 'The location that the Container App (and other created resources) will be deployed to. To view locations suitable
for creating the Container App in, please run the following: az provider show -n Microsoft.App --query "resourceTypes[?resourceType=='containerApps'].locations"'

    location: # optional
    # 'A list of environment variable(s) for the container. Space-separated values in 'key=value' format. Empty string
to clear existing values. Prefix value with 'secretref:' to reference a secret.'

    environmentVariables: # optional
    # 'Possible options: external, internal, disabled. If set to "external" (default value if not provided when creating
a Container App), the Container App will be visible from the internet or a VNET, depending on the app environment
endpoint configured. If set to "internal", the Container App will be visible from within the app environment only.
If set to "disabled", ingress will be disabled for this Container App and will not have an HTTP or TCP endpoint.'

    ingress: # optional
    # 'Full path (on the executing GitHub runner) to the YAML file detailing the configuration of the Container App.
The 'resourceGroup' property in the YAML file will not be used; the value for this either comes from the
'resourceGroup' argument provided to the action, or the default resource group name generated by the action.
Image and application source arguments (e.g., 'appSourcePath', 'imageToDeploy') will still be used to first build
and/or push an image that is used by the Container App; in this case, the provided YAML configuration file will
need to reference the image specified by 'imageToDeploy' (or 'imageToBuild', depending on your scenario). When
creating a new Container App, all properties listed in the file will be set when the Container App is created.
When updating an existing Container App, only the properties listed in the file will be updated on the Container
App. For more information on the structure of this YAML configuration file, please visit
https://aka.ms/azure-container-apps-yaml'

    yamlConfigPath: # optional
    # 'If set to "true", no telemetry will be collected by this GitHub Action. If set to "false", or if this argument is
not provided, telemetry will be sent to Microsoft about the Container App build and deploy scenario targeted by
this GitHub Action.'

    disableTelemetry: # optional
